# ==============================================================================
#
#                               PORTFOLIO CLASS
#
# ==============================================================================
#
# FILE: portfolio.py
#
# PURPOSE:
#   This module defines the `Portfolio` class, which is responsible for
#   managing the state of our trading account. This includes tracking capital,
#   positions, and calculating P&L. Also contains the `PositionManager` class
#   for unified trade and position management logic.
#
# CONSOLIDATED FROM:
#   - position_manager.py (Enhanced PositionManager class + SmartOrderManager)
#
# ==============================================================================

import numpy as np
from core.position_manager import PositionManager
import pandas as pd
import time
import logging
import asyncio
from typing import Optional
from dataclasses import dataclass
from enum import Enum

# Import MarketRegime for regime-aware position sizing
from .enums import MarketRegime
# from .position_manager import PositionManager

# Set up logger
logger = logging.getLogger(__name__)

# ==============================================================================
# ORDER MANAGEMENT CLASSES (consolidated from position_manager.py)
# ==============================================================================

class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    TRAILING_STOP = "trailing_stop"


    def calculate_equity(self, *args, **kwargs):
        # TODO: Implement calculate_equity
        # Auto-generated by health utils safety system
        pass


    def cash(self, *args, **kwargs):
        # TODO: Implement cash
        # Auto-generated by health utils safety system
        pass

class OrderStatus(Enum):
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"

@dataclass
class SmartOrder:
    id: str
    symbol: str
    side: str  # 'buy' or 'sell'
    order_type: OrderType
    size: float
    price: Optional[float] = None
    stop_price: Optional[float] = None
    status: OrderStatus = OrderStatus.PENDING
    created_at: float = None
    filled_at: Optional[float] = None
    fill_price: Optional[float] = None
    parent_order_id: Optional[str] = None
    retry_count: int = 0
    max_retries: int = 3

# ==============================================================================
# POSITION MANAGEMENT CLASSES
# ==============================================================================

class Portfolio:
    """
    A class to manage the portfolio and track its performance.
    This class is simplified to focus on capital management and trade history.
    Performance metrics are calculated separately.
    """
    def __init__(self, initial_capital=10000):
        # HEALTH CHECK: Ensure system health before portfolio initialization
        try:
            import sys
            import os
            # Add parent directory to path to find utilities
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if parent_dir not in sys.path:
                sys.path.insert(0, parent_dir)
            from utilities.utils import safe_health_check
            safe_health_check("Portfolio", silent=True)
        except Exception:
            # Any error in health check - proceed with warning
            pass
            
        # Enhanced configuration loading for portfolio
        try:
            from utilities.utils import config_manager
            portfolio_config = config_manager.get_config(None, 'portfolio')
            self.initial_capital = float(portfolio_config.get('INITIAL_CAPITAL', initial_capital))
            self.safety_warning_interval = portfolio_config.get('SAFETY_WARNING_INTERVAL', 5000)
        except Exception:
            # Fallback to provided values
            self.initial_capital = float(initial_capital)
            self.safety_warning_interval = 5000
        self.cash = float(self.initial_capital)
        self.history = []
        self.equity_curve = [(pd.Timestamp.min, self.initial_capital)] # Start with initial capital
        
        # Warning reduction counters  
        self.safety_check_count = 0
    
    def record_trade(self, entry_timestamp, exit_timestamp, entry_price, exit_price, size, trade_type, pnl, exit_reason, window_num, window_start_capital, position_manager=None, strategy_params=None, comprehensive_manager=None):
        """
        Records a completed trade to the portfolio's history and updates capital.
        Enhanced to integrate with dynamic risk management and comprehensive results manager.
        FIXED: Added safety check to prevent negative equity in 0-margin strategy.
        """
        # CRITICAL SAFETY CHECK: Prevent negative equity in 0-margin strategy
        new_cash = self.cash + pnl
        if new_cash < 0:
            self.safety_check_count += 1
            
            # No individual warnings - only track count for final summary
            pnl = -self.cash + 0.01  # Leave $0.01 to prevent complete wipeout
            new_cash = 0.01
        
        self.cash = new_cash
        # Attempt to capture position diagnostics before reset (bars_in_trade, excursions)
        bars_in_trade = None
        max_adverse = None
        max_favorable = None
        try:
            if position_manager and hasattr(position_manager, 'position_details') and position_manager.position_details:
                pdets = position_manager.position_details
                bars_in_trade = pdets.get('bars_in_trade')
                max_adverse = pdets.get('max_adverse_excursion')
                max_favorable = pdets.get('max_favorable_excursion')
        except Exception:
            pass

        trade_record = {
            'entry_timestamp': entry_timestamp,
            'exit_timestamp': exit_timestamp,
            'entry_price': entry_price,
            'exit_price': exit_price,
            'size': size,
            'trade_type': trade_type,
            'pnl': pnl,
            'final_equity': self.cash, # The equity after the trade is closed
            'exit_reason': exit_reason,
            'window': window_num,
            'window_start_capital': window_start_capital,
            'bars_in_trade': bars_in_trade,
            'max_adverse_excursion': max_adverse,
            'max_favorable_excursion': max_favorable
        }
        # Attach market regime if available from position manager details
        try:
            if position_manager and hasattr(position_manager, 'position_details'):
                # Use the snapshot of position details captured before exit if passed separately
                if position_manager and hasattr(position_manager, 'last_closed_position'):
                    regime = getattr(position_manager, 'last_closed_position', {}).get('market_regime')
                else:
                    regime = position_manager.position_details.get('market_regime') if position_manager.position_details else None
                if regime:
                    trade_record['market_regime'] = regime
        except Exception:
            pass
        
        # Add strategy parameters to trade record for analysis
        if strategy_params:
            # Ichimoku parameters
            trade_record['TENKAN_SEN_PERIOD'] = strategy_params.get('TENKAN_SEN_PERIOD', None)
            trade_record['KIJUN_SEN_PERIOD'] = strategy_params.get('KIJUN_SEN_PERIOD', None)
            trade_record['SENKOU_SPAN_B_PERIOD'] = strategy_params.get('SENKOU_SPAN_B_PERIOD', None)
            
            # RSI parameters
            trade_record['RSI_PERIOD'] = strategy_params.get('RSI_PERIOD', None)
            trade_record['RSI_OVERBOUGHT'] = strategy_params.get('RSI_OVERBOUGHT', None)
            trade_record['RSI_OVERSOLD'] = strategy_params.get('RSI_OVERSOLD', None)
            
            # Confidence and signal parameters
            trade_record['min_confidence'] = strategy_params.get('min_confidence', None)
            trade_record['strong_signal_threshold'] = strategy_params.get('strong_signal_threshold', None)
            trade_record['confluence_threshold'] = strategy_params.get('confluence_threshold', None)
            
            # Volatility parameters
            trade_record['volatility_threshold'] = strategy_params.get('volatility_threshold', None)
            trade_record['volatility_window'] = strategy_params.get('volatility_window', None)
            
            # Trend and momentum parameters
            trade_record['trend_window'] = strategy_params.get('trend_window', None)
            trade_record['momentum_window'] = strategy_params.get('momentum_window', None)
            trade_record['ADX_THRESHOLD'] = strategy_params.get('ADX_THRESHOLD', None)
        
        # Record in comprehensive manager if available
        if comprehensive_manager:
            comprehensive_manager.record_trade_with_parameters(
                entry_timestamp, exit_timestamp, entry_price, exit_price,
                size, trade_type, pnl, self.cash, exit_reason, window_num,
                window_start_capital, strategy_params or {}
            )
        
        self.history.append(trade_record)
        self.equity_curve.append((exit_timestamp, self.cash))
        
        # Update position manager's trade history for dynamic risk management
        if position_manager and hasattr(position_manager, 'update_trade_history'):
            position_manager.update_trade_history(pnl, self.cash)

    def get_trade_history_df(self):
        """
        Returns the trade history as a pandas DataFrame.
        """
        if not self.history:
            return pd.DataFrame()
        return pd.DataFrame(self.history)

    def get_equity_curve_series(self):
        """
        Returns the equity curve as a pandas Series.
        """
        if len(self.equity_curve) <= 1:
            return pd.Series([self.initial_capital])
            
        timestamps, equities = zip(*self.equity_curve)
        # Create a proper time series, starting with the initial capital
        equity_series = pd.Series(data=equities, index=timestamps)
        # Remove the initial placeholder timestamp
        return equity_series.iloc[1:]

    def calculate_performance_metrics(self):
        """
        Calculates key performance metrics from the portfolio's trade history.
        """
        trades_df = self.get_trade_history_df()
        if trades_df.empty:
            return {"Sharpe Ratio": 0.0, "Final Equity": self.initial_capital, "Sortino Ratio": 0.0, "Calmar Ratio": 0.0, "Max Drawdown": 0.0, "Total Trades": 0}

        final_equity = self.cash
        equity_curve = self.get_equity_curve_series()
        
        if equity_curve.empty:
             return {"Sharpe Ratio": 0.0, "Final Equity": self.initial_capital, "Sortino Ratio": 0.0, "Calmar Ratio": 0.0, "Max Drawdown": 0.0, "Total Trades": 0}

        returns = equity_curve.pct_change().dropna()
        
        if returns.empty or returns.std() == 0:
            return {"Sharpe Ratio": 0.0, "Final Equity": final_equity, "Sortino Ratio": 0.0, "Calmar Ratio": 0.0, "Max Drawdown": 0.0, "Total Trades": len(trades_df)}

        # Assuming 5-minute intervals for annualization
        annualization_factor = np.sqrt(252 * (24 * 12)) 
        sharpe = (returns.mean() / returns.std()) * annualization_factor if returns.std() > 0 else 0.0

        peak = equity_curve.expanding(min_periods=1).max()
        drawdown = (equity_curve - peak) / peak
        max_drawdown = drawdown.min() if not drawdown.empty else 0.0

        negative_returns = returns[returns < 0]
        downside_std = negative_returns.std()
        sortino = (returns.mean() / downside_std) * annualization_factor if downside_std > 0 else 0.0
        
        days_in_data = (equity_curve.index[-1] - equity_curve.index[0]).days if len(equity_curve.index) > 1 else 0
        if days_in_data > 0:
            annual_return = (final_equity / self.initial_capital)**(365.25 / days_in_data) - 1
        else:
            annual_return = (final_equity / self.initial_capital) - 1

        calmar = annual_return / abs(max_drawdown) if max_drawdown < 0 else 0.0

        # --- K-Ratio Calculation ---
        k_ratio = self.calculate_k_ratio(equity_curve)

        return {
            "Sharpe Ratio": sharpe,
            "Final Equity": final_equity,
            "Sortino Ratio": sortino,
            "Calmar Ratio": calmar,
            "Max Drawdown": max_drawdown,
            "Total Trades": len(trades_df),
            "K-Ratio": k_ratio
        }

    def calculate_k_ratio(self, equity_curve):
        """
        Calculates the K-Ratio for the given equity curve.
        The K-Ratio is a measure of the stability and consistency of returns.
        """
        if len(equity_curve) < 2:
            return 0.0

        log_equity = np.log(equity_curve)
        x = np.arange(len(log_equity))
        
        # Perform linear regression
        slope, intercept = np.polyfit(x, log_equity, 1)
        
        # Calculate the standard error of the slope
        y_fit = slope * x + intercept
        residuals = log_equity - y_fit
        std_err = np.sqrt(np.sum(residuals**2) / (len(x) - 2)) if len(x) > 2 else 0.0
        
        if std_err == 0:
            return 0.0

        # The K-Ratio is the slope divided by its standard error, annualized.
        # The annualization factor depends on the number of data points per year.
        # Assuming 252 trading days * 24 hours * 12 5-min intervals
        annualization_factor = 252 * 24 * 12
        k_ratio = (slope / std_err) * np.sqrt(annualization_factor)
        
        return k_ratio if np.isfinite(k_ratio) else 0.0
    
    def get_regime_risk_multiplier(self, regime: MarketRegime) -> float:
        """
        Get position sizing multiplier based on market regime.
        Enhanced for 9-regime system with volume-confirmed regimes.
        """
        regime_multipliers = {
            # Original 5 regimes
            MarketRegime.TRENDING_BULL: 1.2,        # More aggressive in bull trends
            MarketRegime.TRENDING_BEAR: 0.8,        # Defensive in bear trends
            MarketRegime.HIGH_VOLATILITY: 0.5,      # Very defensive in high volatility
            MarketRegime.LOW_VOLATILITY: 1.1,       # Slightly more aggressive in low volatility
            MarketRegime.RANGING: 0.9,              # Slightly defensive in ranging markets
            
            # New 4 regimes from advanced system
            MarketRegime.BREAKOUT_BULLISH: 1.5,     # Very aggressive on bullish breakouts
            MarketRegime.BREAKOUT_BEARISH: 0.6,     # Very defensive on bearish breakouts
            MarketRegime.ACCUMULATION: 1.1,         # Moderate increase during accumulation
            MarketRegime.DISTRIBUTION: 0.7          # Defensive during distribution
        }
        
        return regime_multipliers.get(regime, 1.0)  # Default to 1.0 if regime not found
    
    def calculate_regime_adjusted_position_size(self, base_position_size: float, regime: MarketRegime) -> float:
        """
        Calculate position size adjusted for market regime.
        
        Args:
            base_position_size: Base position size before regime adjustment
            regime: Current market regime
            
        Returns:
            Regime-adjusted position size
        """
        try:
            regime_multiplier = self.get_regime_risk_multiplier(regime)
            adjusted_size = base_position_size * regime_multiplier
            
            # Apply reasonable bounds
            max_adjustment = base_position_size * 2.0  # Don't exceed 2x base size
            min_adjustment = base_position_size * 0.3  # Don't go below 30% of base size
            
            return max(min_adjustment, min(max_adjustment, adjusted_size))
            
        except Exception as e:
            # Log error and return base size as fallback
            logging.error(f"Error calculating regime-adjusted position size: {e}")
            return base_position_size

# ==============================================================================
# SMART ORDER MANAGEMENT (consolidated from position_manager.py)
# ==============================================================================

class SmartOrderManager:
    """
    Advanced order management with intelligent execution strategies
    Integrated into position management pipeline
    """
    
    def __init__(self, exchange, params):
        self.exchange = exchange
        self.params = params
        self.active_orders = {}
        self.order_history = []
        self.logger = logging.getLogger("SmartOrderManager")
        
        # Order execution settings
        self.max_slippage = params.get('MAX_SLIPPAGE', 0.002)  # 0.2%
        self.order_timeout = params.get('ORDER_TIMEOUT', 300)  # 5 minutes
        self.partial_fill_threshold = params.get('PARTIAL_FILL_THRESHOLD', 0.8)  # 80%
        
    async def submit_smart_order(self, order: SmartOrder) -> bool:
        """Submit order with intelligent execution strategy"""
        
        if order.created_at is None:
            order.created_at = time.time()
            
        self.active_orders[order.id] = order
        
        try:
            # Choose execution strategy based on order type and market conditions
            if order.order_type == OrderType.MARKET:
                success = await self._execute_market_order_smart(order)
            elif order.order_type == OrderType.LIMIT:
                success = await self._execute_limit_order_smart(order)
            else:
                success = await self._execute_standard_order(order)
                
            if success:
                order.status = OrderStatus.SUBMITTED
                self.logger.info(f"Order {order.id} submitted successfully")
                
                # Start monitoring task
                asyncio.create_task(self._monitor_order(order))
                
            return success
            
        except Exception as e:
            self.logger.error(f"Failed to submit order {order.id}: {e}")
            order.status = OrderStatus.REJECTED
            return False
    
    async def _execute_market_order_smart(self, order: SmartOrder) -> bool:
        """Execute market order with slippage protection"""
        
        # Get current market price
        ticker = await self.exchange.fetch_ticker(order.symbol)
        current_price = ticker['bid'] if order.side == 'sell' else ticker['ask']
        
        # Check for excessive spread
        spread = (ticker['ask'] - ticker['bid']) / ticker['last']
        if spread > self.max_slippage * 2:
            self.logger.warning(f"High spread detected ({spread:.4f}). Converting to limit order.")
            return await self._execute_as_limit_order(order, current_price)
        
        # Execute market order
        try:
            exchange_order = await self.exchange.create_market_order(
                order.symbol, order.side, order.size
            )
            
            order.fill_price = exchange_order.get('average', current_price)
            order.filled_at = time.time()
            order.status = OrderStatus.FILLED
            
            return True
            
        except Exception as e:
            self.logger.error(f"Market order execution failed: {e}")
            return False
    
    async def _execute_limit_order_smart(self, order: SmartOrder) -> bool:
        """Execute limit order with dynamic pricing"""
        
        # Get current market depth
        orderbook = await self.exchange.fetch_order_book(order.symbol)
        
        # Adjust limit price based on market conditions
        optimal_price = self._calculate_optimal_limit_price(order, orderbook)
        
        if optimal_price != order.price:
            self.logger.info(f"Adjusting limit price from {order.price} to {optimal_price}")
            order.price = optimal_price
        
        return await self._execute_standard_order(order)
    
    def _calculate_optimal_limit_price(self, order: SmartOrder, orderbook: dict) -> float:
        """Calculate optimal limit price based on orderbook"""
        
        if order.side == 'buy':
            # For buy orders, check bid levels
            best_bid = orderbook['bids'][0][0] if orderbook['bids'] else order.price
            # Place slightly above best bid for better fill probability
            optimal_price = min(order.price, best_bid + (best_bid * 0.0001))
        else:
            # For sell orders, check ask levels
            best_ask = orderbook['asks'][0][0] if orderbook['asks'] else order.price
            # Place slightly below best ask for better fill probability
            optimal_price = max(order.price, best_ask - (best_ask * 0.0001))
        
        return optimal_price
    
    async def _execute_standard_order(self, order: SmartOrder) -> bool:
        """Execute standard order through exchange"""
        try:
            if order.order_type == OrderType.LIMIT:
                exchange_order = await self.exchange.create_limit_order(
                    order.symbol, order.side, order.size, order.price
                )
            elif order.order_type == OrderType.MARKET:
                exchange_order = await self.exchange.create_market_order(
                    order.symbol, order.side, order.size
                )
            else:
                return False  # Unsupported order type
            
            # Store exchange order ID for monitoring
            order.exchange_id = exchange_order['id']
            return True
            
        except Exception as e:
            self.logger.error(f"Standard order execution failed: {e}")
            return False
    
    async def _monitor_order(self, order: SmartOrder):
        """Monitor order execution and handle partial fills"""
        start_time = time.time()
        
        while order.status in [OrderStatus.SUBMITTED, OrderStatus.PENDING]:
            # Check timeout
            if time.time() - start_time > self.order_timeout:
                await self._handle_order_timeout(order)
                break
            
            try:
                # Check order status
                exchange_order = await self.exchange.fetch_order(order.exchange_id, order.symbol)
                
                if exchange_order['status'] == 'closed':
                    order.status = OrderStatus.FILLED
                    order.filled_at = time.time()
                    order.fill_price = exchange_order.get('average', order.price)
                    break
                elif exchange_order['status'] == 'canceled':
                    order.status = OrderStatus.CANCELLED
                    break
                
                # Check for partial fills
                filled_amount = exchange_order.get('filled', 0)
                if filled_amount > 0 and filled_amount < order.size:
                    fill_ratio = filled_amount / order.size
                    if fill_ratio >= self.partial_fill_threshold:
                        # Accept partial fill
                        order.size = filled_amount
                        order.status = OrderStatus.FILLED
                        order.filled_at = time.time()
                        order.fill_price = exchange_order.get('average', order.price)
                        break
                
            except Exception as e:
                self.logger.error(f"Error monitoring order {order.id}: {e}")
                
            await asyncio.sleep(5)  # Check every 5 seconds
    
    async def _handle_order_timeout(self, order: SmartOrder):
        """Handle order timeout"""
        try:
            # Cancel the order
            await self.exchange.cancel_order(order.exchange_id, order.symbol)
            order.status = OrderStatus.CANCELLED
            self.logger.warning(f"Order {order.id} timed out and was cancelled")
            
        except Exception as e:
            self.logger.error(f"Failed to cancel timed out order {order.id}: {e}")
    
    def get_order_statistics(self) -> dict:
        """Get order execution statistics"""
        if not self.order_history:
            return {}
        
        filled_orders = [o for o in self.order_history if o.status == OrderStatus.FILLED]
        
        return {
            'total_orders': len(self.order_history),
            'filled_orders': len(filled_orders),
            'fill_rate': len(filled_orders) / len(self.order_history) if self.order_history else 0,
            'average_fill_time': np.mean([o.filled_at - o.created_at for o in filled_orders]) if filled_orders else 0
        }
    
    def get_safety_summary(self):
        """Get a summary of safety checks during the session"""
        return {
            'safety_checks': self.safety_check_count
        }
    
    def log_session_summary(self):
        """Log a summary of portfolio safety activity at the end of session"""
        if self.safety_check_count > 0:
            logger.info(f"Portfolio Session Summary: "
                       f"{self.safety_check_count} negative equity preventions applied")
        else:
            logger.debug("Portfolio Session Summary: No safety checks needed")
    
    def create_order_id(self) -> str:
        """Generate unique order ID"""
        return f"order_{int(time.time() * 1000000)}"
