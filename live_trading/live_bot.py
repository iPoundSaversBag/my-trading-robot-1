# ==============================================================================
#
#                               LIVE TRADING BOT
#
# ==============================================================================
#
# FILE: live_bot.py
#
# PURPOSE:
#   This script is the execution engine for the live trading strategy. It is
#   designed to connect to the Binance exchange, monitor market data in real-time,
#   and execute trades based on the signals generated by the strategy that was
#   optimized by the backtesting framework.
#
# METHODOLOGY:
#   The bot operates in a continuous loop, fetching the latest market data at
#   regular intervals. In each iteration, it:
#   1.  Loads the most recently optimized parameters from `final_optimized_params.json`.
#   2.  Calculates all necessary technical indicators (Ichimoku, RSI, ADX, etc.)
#       based on the latest data and the loaded parameters.
#   3.  Generates entry and exit signals according to the same logic used in the
#       backtester.
#   4.  Connects to the Binance API to manage the account, check for open
#       positions, and execute new trades (buy/sell orders).
#   5.  Implements risk management rules, such as setting stop-loss and take-profit
#       levels for all trades.
#
# KEY FEATURES:
#   - Real-Time Operation: Designed to run continuously, making trading
#     decisions based on live market data.
#   - Exchange Integration: Uses the `binance.client` library to interact
#     directly with the Binance exchange for order execution and account management.
#   - Dynamic Parameter Loading: Automatically uses the latest and best parameters
#     found by the `watcher.py` optimization pipeline.
#   - Consistent Logic: Employs the exact same signal generation and trade
#     management logic as the backtester to ensure that live performance is
#     as close as possible to the simulated results.
#
# ==============================================================================

# live_bot.py - A framework for live trading that mirrors the backtester's logic.
# WARNING: FOR EDUCATIONAL AND PAPER-TRADING PURPOSES ONLY.
# DO NOT USE WITH A REAL MONEY ACCOUNT WITHOUT SIGNIFICANT TESTING AND ADDING MORE ROBUSTNESS.

import asyncio
import json
import os
import glob
import pandas as pd
import ta
import datetime
import sys
import ccxt.pro as ccxt
import warnings
import numpy as np
import traceback
import time
from google.api_core import exceptions
from ta.momentum import rsi
from ta.trend import adx, macd_diff
from dotenv import load_dotenv
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# CONSOLIDATED NOTIFICATIONS MODULE (from live_trading/notifications.py)
import logging

# Setup logging for notifications
logging.basicConfig(level=logging.INFO)
notification_logger = logging.getLogger(__name__)

def send_notification(message, title="Trading Robot Notification"):
    """Send a basic notification (file-based)"""
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        notification_log = "logs/notifications.log"
        
        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        
        with open(notification_log, 'a') as f:
            f.write(f"[{timestamp}] {title}: {message}\n")
        
        notification_logger.info(f"Notification: {title} - {message}")
        return True
    except Exception as e:
        notification_logger.error(f"Failed to send notification: {e}")
        return False

def send_error_alert(error_message, context="Trading Robot"):
    """Send an error alert notification"""
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        error_log = "logs/error_alerts.log"
        
        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        
        with open(error_log, 'a') as f:
            f.write(f"[{timestamp}] ERROR in {context}: {error_message}\n")
        
        notification_logger.error(f"Error Alert: {context} - {error_message}")
        return True
    except Exception as e:
        notification_logger.error(f"Failed to send error alert: {e}")
        return False


# ==============================================================================
# ENHANCED NOTIFICATION SYSTEM (FROM BACKUP CONSOLIDATION)
# ==============================================================================

def send_trade_alert(action, symbol, price, quantity, stop_loss=None, take_profit=None):
    """
    Enhanced trade alert notification with comprehensive trade details.
    Consolidated from notifications_live_trading.py.backup.
    """
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        trade_log = "logs/trade_alerts.log"
        
        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        
        # Construct detailed trade message
        trade_details = {
            'timestamp': timestamp,
            'action': action.upper(),
            'symbol': symbol,
            'price': price,
            'quantity': quantity,
            'stop_loss': stop_loss,
            'take_profit': take_profit
        }
        
        # Format message
        message = f"TRADE EXECUTED: {action.upper()} {quantity} {symbol} @ {price}"
        if stop_loss:
            message += f" | SL: {stop_loss}"
        if take_profit:
            message += f" | TP: {take_profit}"
        
        # Log to trade alerts file
        with open(trade_log, 'a') as f:
            f.write(f"[{timestamp}] {message}\n")
            f.write(f"    Details: {json.dumps(trade_details, indent=4)}\n")
        
        # Send general notification
        send_notification(message, "Trade Execution Alert")
        
        notification_logger.info(f"Trade Alert: {message}")
        return True
        
    except Exception as e:
        notification_logger.error(f"Failed to send trade alert: {e}")
        return False


def send_portfolio_update(balance, pnl, open_positions=None):
    """
    Send portfolio performance and balance updates.
    Enhanced version with detailed position tracking.
    """
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        portfolio_log = "logs/portfolio_updates.log"
        
        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        
        portfolio_data = {
            'timestamp': timestamp,
            'balance': balance,
            'pnl': pnl,
            'open_positions': open_positions or []
        }
        
        # Format message
        message = f"PORTFOLIO UPDATE: Balance: {balance} | P&L: {pnl}"
        if open_positions:
            message += f" | Open Positions: {len(open_positions)}"
        
        # Log to portfolio file
        if not os.path.exists(portfolio_log):
            with open(portfolio_log, 'w') as f:
                f.write("# Portfolio Update Log\n")
        
        with open(portfolio_log, 'a') as f:
            f.write(f"[{timestamp}] {message}\n")
            f.write(f"    Details: {json.dumps(portfolio_data, indent=4)}\n")
        
        notification_logger.info(f"Portfolio Update: {message}")
        return True
        
    except Exception as e:
        notification_logger.error(f"Failed to send portfolio update: {e}")
        return False


def send_system_status(status, uptime=None, last_trade=None, performance_metrics=None):
    """
    Send comprehensive system status notifications.
    Enhanced monitoring for live trading operations.
    """
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        status_log = "logs/system_status.log"
        
        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        
        status_data = {
            'timestamp': timestamp,
            'status': status,
            'uptime': uptime,
            'last_trade': last_trade,
            'performance_metrics': performance_metrics or {}
        }
        
        # Format message
        message = f"SYSTEM STATUS: {status.upper()}"
        if uptime:
            message += f" | Uptime: {uptime}"
        if last_trade:
            message += f" | Last Trade: {last_trade}"
        
        # Log to system status file
        if not os.path.exists(status_log):
            with open(status_log, 'w') as f:
                f.write("# System Status Log\n")
        
        with open(status_log, 'a') as f:
            f.write(f"[{timestamp}] {message}\n")
            if performance_metrics:
                f.write(f"    Performance: {json.dumps(performance_metrics, indent=4)}\n")
        
        # Send notification for critical status changes
        if status.lower() in ['error', 'stopped', 'disconnected', 'critical']:
            send_notification(message, "System Status Alert")
            send_error_alert(f"System status changed to: {status}", "Live Trading Bot")
        
        notification_logger.info(f"System Status: {message}")
        return True
        
    except Exception as e:
        notification_logger.error(f"Failed to send system status: {e}")
        return False


def send_strategy_alert(signal_type, symbol, timeframe, confidence=None, indicators=None):
    """
    Send strategy-specific alerts for signal generation.
    Enhanced version with indicator details and confidence scoring.
    """
    try:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        strategy_log = "logs/strategy_alerts.log"
        
        # Ensure logs directory exists
        os.makedirs("logs", exist_ok=True)
        
        alert_data = {
            'timestamp': timestamp,
            'signal_type': signal_type,
            'symbol': symbol,
            'timeframe': timeframe,
            'confidence': confidence,
            'indicators': indicators or {}
        }
        
        # Format message
        message = f"STRATEGY ALERT: {signal_type.upper()} signal for {symbol} ({timeframe})"
        if confidence:
            message += f" | Confidence: {confidence:.2f}"
        
        # Log to strategy alerts file
        if not os.path.exists(strategy_log):
            with open(strategy_log, 'w') as f:
                f.write("# Strategy Alerts Log\n")
        
        with open(strategy_log, 'a') as f:
            f.write(f"[{timestamp}] {message}\n")
            if indicators:
                f.write(f"    Indicators: {json.dumps(indicators, indent=4)}\n")
        
        # Send notification for high-confidence signals
        if confidence and confidence > 0.7:
            send_notification(message, "High Confidence Signal")
        
        notification_logger.info(f"Strategy Alert: {message}")
        return True
        
    except Exception as e:
        notification_logger.error(f"Failed to send strategy alert: {e}")
        return False


def cleanup_old_logs(days_to_keep=30):
    """
    Clean up old notification logs to prevent disk space issues.
    Enhanced version with configurable retention period.
    """
    try:
        current_time = datetime.datetime.now()
        cutoff_date = current_time - datetime.timedelta(days=days_to_keep)
        
        log_files = [
            'logs/notifications.log',
            'logs/error_alerts.log', 
            'logs/trade_alerts.log',
            'logs/portfolio_updates.log',
            'logs/system_status.log',
            'logs/strategy_alerts.log'
        ]
        
        cleaned_files = []
        
        for log_file in log_files:
            if os.path.exists(log_file):
                # Read and filter log lines
                with open(log_file, 'r') as f:
                    lines = f.readlines()
                
                filtered_lines = []
                for line in lines:
                    if line.startswith('['):
                        try:
                            # Extract timestamp from log line
                            timestamp_str = line[1:20]  # Extract YYYY-MM-DD HH:MM:SS
                            log_time = datetime.datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
                            
                            if log_time >= cutoff_date:
                                filtered_lines.append(line)
                        except ValueError:
                            # Keep lines that can't be parsed (headers, etc.)
                            filtered_lines.append(line)
                    else:
                        # Keep non-timestamped lines (details, etc.)
                        filtered_lines.append(line)
                
                # Write back filtered content
                if len(filtered_lines) < len(lines):
                    with open(log_file, 'w') as f:
                        f.writelines(filtered_lines)
                    
                    removed_lines = len(lines) - len(filtered_lines)
                    cleaned_files.append(f"{log_file}: {removed_lines} old entries removed")
        
        if cleaned_files:
            cleanup_message = f"Log cleanup completed: {', '.join(cleaned_files)}"
            notification_logger.info(cleanup_message)
            send_system_status("maintenance", performance_metrics={'log_cleanup': cleanup_message})
        
        return True
        
    except Exception as e:
        notification_logger.error(f"Failed to cleanup old logs: {e}")
        return False

def send_email_notification(subject, message, to_email=None):
    """Placeholder for email notifications (not implemented)"""
    notification_logger.warning("Email notifications not implemented - using file-based notifications instead")
    return send_notification(message, subject)

NOTIFICATIONS_AVAILABLE = True

try:
    from core.strategy import MultiTimeframeStrategy
    STRATEGY_AVAILABLE = True
except ImportError:
    STRATEGY_AVAILABLE = False
    print("⚠️  Strategy module not available")

try:
    from core.position_manager import PositionManager
    POSITION_MANAGER_AVAILABLE = True
except ImportError:
    POSITION_MANAGER_AVAILABLE = False
    print("⚠️  Position manager module not available")

try:
    from core.portfolio import Portfolio
    PORTFOLIO_AVAILABLE = True
except ImportError:
    PORTFOLIO_AVAILABLE = False
    print("⚠️  Portfolio module not available")

try:
    from utilities.gcp_utils import download_from_gcs, get_gcs_blob_metadata
    GCP_AVAILABLE = True
except ImportError:
    GCP_AVAILABLE = False
    print("⚠️  GCP utilities not available - using local parameters only")
    
    # Create dummy GCP functions for fallback
    def download_from_gcs(source_blob_name, destination_file_path):
        return False
    
    def get_gcs_blob_metadata(blob_name):
        return None

load_dotenv()
API_KEY = os.getenv("API_KEY")
SECRET_KEY = os.getenv("SECRET_KEY")

# -------------------------------------------


# ==============================================================================
# SECTION 2: CORE BOT SETTINGS
# ==============================================================================
# -- Exchange and Symbol --
EXCHANGE_ID = 'binance'
SYMBOL = 'BTC/USDT'
TIMEFRAME = '5m'
SANDBOX_MODE = True

# -- File Paths --
PARAMS_BASE_DIR = "plots_output"
STATE_FILE = "data/live_bot_state.json"
LOG_FILE = "logs/live_bot.log"  # Centralized logging path

# --- Set to False when you are ready to trade with real money ---


# ==============================================================================
# ENHANCED SMART ORDER MANAGEMENT SYSTEM
# ==============================================================================

from enum import Enum
from dataclasses import dataclass

class OrderType(Enum):
    """Enhanced order types for smart order management"""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    ICEBERG = "iceberg"
    TWAP = "twap"  # Time-Weighted Average Price
    VWAP = "vwap"  # Volume-Weighted Average Price

@dataclass
class SmartOrder:
    """Smart order with enhanced execution strategies"""
    symbol: str
    side: str  # 'buy' or 'sell'
    amount: float
    order_type: OrderType
    price: float = None
    stop_price: float = None
    time_in_force: str = 'GTC'
    execution_strategy: dict = None
    slippage_tolerance: float = 0.001
    max_execution_time: int = 300  # seconds
    child_orders: list = None
    
    def __post_init__(self):
        if self.execution_strategy is None:
            self.execution_strategy = {}
        if self.child_orders is None:
            self.child_orders = []

class SmartOrderManager:
    """Advanced order management with intelligent execution strategies"""
    
    def __init__(self, exchange):
        self.exchange = exchange
        self.active_orders = {}
        self.execution_history = []
        self.market_impact_threshold = 0.002
    
    def submit_smart_order(self, smart_order: SmartOrder):
        """Submit a smart order with intelligent execution strategy"""
        try:
            if smart_order.order_type == OrderType.MARKET:
                return self._execute_market_order_smart(smart_order)
            elif smart_order.order_type == OrderType.LIMIT:
                return self._execute_limit_order_smart(smart_order)
            elif smart_order.order_type == OrderType.ICEBERG:
                return self._execute_iceberg_order(smart_order)
            elif smart_order.order_type == OrderType.TWAP:
                return self._execute_twap_order(smart_order)
            elif smart_order.order_type == OrderType.VWAP:
                return self._execute_vwap_order(smart_order)
            else:
                log_message(f"Unsupported order type: {smart_order.order_type}")
                return None
        except Exception as e:
            log_message(f"Error submitting smart order: {e}")
            return None
    
    def _execute_market_order_smart(self, order: SmartOrder):
        """Execute market order with slippage protection"""
        try:
            # Get current market price for slippage check
            ticker = self.exchange.fetch_ticker(order.symbol)
            current_price = ticker['bid'] if order.side == 'sell' else ticker['ask']
            
            # Check for excessive spread
            spread = (ticker['ask'] - ticker['bid']) / ticker['bid']
            if spread > self.market_impact_threshold:
                log_message(f"High spread detected ({spread:.4f}), using limit order instead")
                optimal_price = self._calculate_optimal_limit_price(order, ticker)
                return self.exchange.create_limit_order(
                    order.symbol, order.side, order.amount, optimal_price
                )
            
            # Execute market order
            result = self.exchange.create_market_order(
                order.symbol, order.side, order.amount
            )
            
            # Track execution
            self.execution_history.append({
                'timestamp': datetime.datetime.now(),
                'order': order,
                'result': result,
                'execution_price': result.get('price', current_price)
            })
            
            log_message(f"Smart market order executed: {order.side} {order.amount} {order.symbol}")
            return result
            
        except Exception as e:
            log_message(f"Error executing smart market order: {e}")
            return None
    
    def _execute_limit_order_smart(self, order: SmartOrder):
        """Execute limit order with dynamic price adjustment"""
        try:
            ticker = self.exchange.fetch_ticker(order.symbol)
            
            # Use provided price or calculate optimal price
            if order.price is None:
                order.price = self._calculate_optimal_limit_price(order, ticker)
            
            # Submit limit order
            result = self.exchange.create_limit_order(
                order.symbol, order.side, order.amount, order.price
            )
            
            # Store for monitoring
            self.active_orders[result['id']] = {
                'order': order,
                'result': result,
                'submitted_at': datetime.datetime.now()
            }
            
            log_message(f"Smart limit order submitted: {order.side} {order.amount} {order.symbol} @ {order.price}")
            return result
            
        except Exception as e:
            log_message(f"Error executing smart limit order: {e}")
            return None
    
    def _calculate_optimal_limit_price(self, order: SmartOrder, ticker):
        """Calculate optimal limit price based on market conditions"""
        try:
            bid = ticker['bid']
            ask = ticker['ask']
            spread = ask - bid
            
            if order.side == 'buy':
                # For buy orders, start slightly above bid
                optimal_price = bid + (spread * 0.3)
                # Apply slippage tolerance
                max_price = ask * (1 + order.slippage_tolerance)
                return min(optimal_price, max_price)
            else:
                # For sell orders, start slightly below ask
                optimal_price = ask - (spread * 0.3)
                # Apply slippage tolerance
                min_price = bid * (1 - order.slippage_tolerance)
                return max(optimal_price, min_price)
                
        except Exception as e:
            log_message(f"Error calculating optimal price: {e}")
            # Fallback to market price
            return ticker['ask'] if order.side == 'buy' else ticker['bid']
    
    def _execute_iceberg_order(self, order: SmartOrder):
        """Execute large order in smaller chunks to minimize market impact"""
        try:
            chunk_size = order.execution_strategy.get('chunk_size', order.amount * 0.1)
            chunks = []
            remaining = order.amount
            
            while remaining > 0:
                current_chunk = min(chunk_size, remaining)
                chunk_order = SmartOrder(
                    symbol=order.symbol,
                    side=order.side,
                    amount=current_chunk,
                    order_type=OrderType.LIMIT,
                    slippage_tolerance=order.slippage_tolerance
                )
                
                result = self._execute_limit_order_smart(chunk_order)
                if result:
                    chunks.append(result)
                    remaining -= current_chunk
                    # Wait between chunks to avoid detection
                    time.sleep(order.execution_strategy.get('chunk_delay', 5))
                else:
                    break
            
            log_message(f"Iceberg order completed: {len(chunks)} chunks executed")
            return chunks
            
        except Exception as e:
            log_message(f"Error executing iceberg order: {e}")
            return None
    
    def _execute_twap_order(self, order: SmartOrder):
        """Execute order using Time-Weighted Average Price strategy"""
        try:
            duration = order.execution_strategy.get('duration', 300)  # 5 minutes default
            intervals = order.execution_strategy.get('intervals', 10)
            
            chunk_size = order.amount / intervals
            interval_duration = duration / intervals
            
            chunks = []
            for i in range(intervals):
                chunk_order = SmartOrder(
                    symbol=order.symbol,
                    side=order.side,
                    amount=chunk_size,
                    order_type=OrderType.MARKET
                )
                
                result = self._execute_market_order_smart(chunk_order)
                if result:
                    chunks.append(result)
                
                if i < intervals - 1:  # Don't wait after last chunk
                    time.sleep(interval_duration)
            
            log_message(f"TWAP order completed: {len(chunks)} intervals executed")
            return chunks
            
        except Exception as e:
            log_message(f"Error executing TWAP order: {e}")
            return None
    
    def _execute_vwap_order(self, order: SmartOrder):
        """Execute order using Volume-Weighted Average Price strategy"""
        try:
            # Simplified VWAP - would need historical volume data for full implementation
            log_message("VWAP execution - using adaptive market order")
            return self._execute_market_order_smart(order)
            
        except Exception as e:
            log_message(f"Error executing VWAP order: {e}")
            return None
    
    def monitor_active_orders(self):
        """Monitor and manage active orders"""
        try:
            for order_id, order_info in list(self.active_orders.items()):
                # Check order status
                try:
                    status = self.exchange.fetch_order(order_id, order_info['order'].symbol)
                    
                    if status['status'] in ['closed', 'canceled']:
                        # Order completed, remove from active
                        del self.active_orders[order_id]
                        self.execution_history.append({
                            'timestamp': datetime.datetime.now(),
                            'order': order_info['order'],
                            'result': status,
                            'execution_price': status.get('price')
                        })
                    
                except Exception as e:
                    log_message(f"Error checking order {order_id}: {e}")
                    
        except Exception as e:
            log_message(f"Error monitoring active orders: {e}")
    
    def cancel_order(self, order_id):
        """Cancel an active order"""
        try:
            if order_id in self.active_orders:
                order_info = self.active_orders[order_id]
                result = self.exchange.cancel_order(order_id, order_info['order'].symbol)
                del self.active_orders[order_id]
                log_message(f"Order {order_id} canceled successfully")
                return result
        except Exception as e:
            log_message(f"Error canceling order {order_id}: {e}")
            return None
    
    def get_execution_statistics(self):
        """Get execution performance statistics"""
        try:
            if not self.execution_history:
                return {}
            
            total_orders = len(self.execution_history)
            successful_orders = sum(1 for h in self.execution_history if h['result'].get('status') == 'closed')
            success_rate = successful_orders / total_orders if total_orders > 0 else 0
            
            return {
                'total_orders': total_orders,
                'successful_orders': successful_orders,
                'success_rate': success_rate,
                'active_orders': len(self.active_orders)
            }
        except Exception as e:
            log_message(f"Error calculating execution statistics: {e}")
            return {}


# ==============================================================================
# SECTION 3: HELPER FUNCTIONS & CLASSES (DO NOT MODIFY)
# ==============================================================================

# Import centralized logging system
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utilities.utils import log_message as _log_message

# Wrapper function for live_bot specific logging
def log_message(message):
    """Live bot specific logging wrapper"""
    _log_message(message, 'live_bot')

def load_state():
    """Loads the bot's current state (e.g., if it's in a position)."""
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, 'r') as f:
            log_message("State file found. Loading previous state.")
            return json.load(f)
    log_message("No state file found. Starting fresh.")
    return {"in_position": False, "position_details": {}}

def save_state(state):
    """Saves the bot's current state to a file after every action."""
    def default_serializer(o):
        """Converts non-serializable objects to a serializable format."""
        if isinstance(o, (datetime.datetime, pd.Timestamp)):
            return o.isoformat()
        raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")

    with open(STATE_FILE, 'w') as f:
        json.dump(state, f, indent=4, default=default_serializer)

def load_latest_parameters_from_gcs(retries=5, delay=2):
    """
    Downloads and loads the latest parameters from Google Cloud Storage, with retries.
    """
    local_params_file = "data/latest_live_parameters.json"
    for attempt in range(retries):
        try:
            log_message("Attempting to download latest parameters from GCS...")
            download_success = download_from_gcs(
                source_blob_name="latest_live_parameters.json",
                destination_file_path=local_params_file
            )

            if not download_success:
                raise FileNotFoundError("Failed to download parameters from GCS.")

            log_message(f"Successfully downloaded parameters. Loading from '{local_params_file}'")
            with open(local_params_file, 'r') as f:
                all_params = json.load(f)

            # Filter out metadata and sync keys, only keep Window_* keys
            window_keys = [k for k in all_params.keys() if k.startswith('Window_')]
            if not window_keys:
                raise ValueError("No Window_* keys found in parameters file")
                
            last_window_key = sorted(window_keys, key=lambda w: int(w.split('_')[1]))[-1]
            log_message(f"Using parameters from '{last_window_key}' (found {len(window_keys)} windows).")

            with open("core/optimization_config.json", 'r') as cfg_f:
                main_config = json.load(cfg_f)  # Changed from json5 to json
                fixed_params = main_config.get('fixed_parameters', {})
                optimization_settings = main_config.get('optimization_settings', {})

            final_params = {**all_params[last_window_key], **fixed_params, **optimization_settings}
            
            # Get metadata for the update check loop
            blob = get_gcs_blob_metadata("latest_live_parameters.json")
            last_updated = blob.updated if blob else None

            return final_params, last_updated

        except (FileNotFoundError, json.JSONDecodeError, exceptions.GoogleAPICallError) as e:
            if attempt < retries - 1:
                log_message(f"Attempt {attempt + 1}/{retries} failed to load GCS parameters: {e}. Retrying in {delay}s...")
                time.sleep(delay)
            else:
                log_message(f"CRITICAL: Could not load parameters from GCS after {retries} attempts. Last error: {e}")
                raise
    return None, None


def load_latest_parameters_local():
    """
    Fallback function to load parameters locally when GCP is not available.
    """
    try:
        log_message("GCP not available. Loading parameters from local config...")
        with open("core/optimization_config.json", 'r') as f:
            config = json.load(f)
        
        # Get parameter spaces and use their bounds to create default parameters
        param_spaces = config.get('parameter_spaces', {}).get('global', [])
        default_params = {}
        
        for param in param_spaces:
            param_name = param.get('name')
            param_type = param.get('type', 'Integer') # Default to Integer if not specified
            bounds = param.get('bounds', [10, 50])
            
            # Calculate the middle of the bounds as the default value
            mid_point = (bounds[0] + bounds[1]) / 2
            
            # Set the default value based on the parameter type
            if param_type == 'Float':
                default_params[param_name] = float(mid_point)
            else: # Integer
                default_params[param_name] = int(mid_point)
        
        # Add any fixed parameters from config
        fixed_params = config.get('fixed_parameters', {})
        optimization_settings = config.get('optimization_settings', {})
        
        final_params = {**default_params, **fixed_params, **optimization_settings}
        
        log_message(f"Loaded {len(final_params)} parameters from local config")
        return final_params, None
        
    except Exception as e:
        log_message(f"CRITICAL: Could not load parameters locally: {e}")
        return None, None


def load_parameters_with_fallback():
    """
    Load parameters from GCS if available, otherwise use local fallback.
    """
    if GCP_AVAILABLE:
        try:
            return load_latest_parameters_from_gcs()
        except Exception as e:
            log_message(f"GCS loading failed: {e}. Falling back to local parameters.")
            return load_latest_parameters_local()
    else:
        log_message("GCP not available. Using local parameters.")
        return load_latest_parameters_local()


# ==============================================================================
# SECTION 4: MAIN BOT LOGIC
# ==============================================================================
async def run():
    """Main function to run the bot."""
    log_message(f"Initializing Live Trading Bot for {SYMBOL} on {EXCHANGE_ID} ({TIMEFRAME})...")
    
    exchange = getattr(ccxt, EXCHANGE_ID)({
        'apiKey': API_KEY,
        'secret': SECRET_KEY,
    })
    if SANDBOX_MODE:
        exchange.set_sandbox_mode(True)

    try:
        initial_state = load_state()
        if initial_state:
            log_message("State file found. Loading previous state.")
        else:
            log_message("No state file found. Starting fresh.")
            initial_state = {'in_position': False, 'position_details': {}}

        # Load parameters
        params, last_gcs_update_time = load_parameters_with_fallback()

        if not params:
            log_message("CRITICAL: Could not load any parameters. Shutting down.")
            return

        # Initialize core components
        strategy = MultiTimeframeStrategy(params)
        position_manager = PositionManager(params)
        position_manager.load_state(initial_state)

        # Start a background task to check for GCS updates
        update_task = asyncio.create_task(
            check_for_parameter_updates(strategy, position_manager, last_gcs_update_time)
        )

        # Main trading loop
        while True:
            try:
                log_message("--- Main loop iteration started ---")
                # Fetch latest data
                ohlcv = await exchange.fetch_ohlcv(SYMBOL, TIMEFRAME, limit=1000)
                log_message(f"Fetched {len(ohlcv)} candles.")
                df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                df.set_index('timestamp', inplace=True)
                
                # Generate signals
                log_message("Generating signals...")
                processed_df = strategy.generate_signals(df)
                log_message("Signal generation complete.")
                latest_candle = processed_df.iloc[-1]
                
                log_message("Checking for exit...")
                # Check for exit first
                if position_manager.in_position:
                    exit_action = position_manager.update_position_management(latest_candle)
                    action = exit_action.get('action')
                    
                    if action in ['exit_full', 'partial_exit']:
                        log_message(f"Exit action triggered: {action}, Reason: {exit_action.get('reason')}")
                        
                        pos_details = position_manager.position_details
                        pos_type = pos_details.get('type')
                        exit_side = 'sell' if pos_type == 'long' else 'buy'
                        
                        if action == 'exit_full':
                            exit_size = pos_details.get('current_size', 0)
                        else: # partial_exit
                            exit_size = pos_details.get('current_size', 0) * pos_details.get('partial_tp_percentage', 0.5)

                        if exit_size > 0:
                            try:
                                log_message(f"Attempting to place {exit_side} order for {exit_size} {SYMBOL.split('/')[0]}")
                                order = await exchange.create_market_order(SYMBOL, exit_side, exit_size)
                                log_message(f"Exit order placed successfully: {order['id']}")
                                
                                send_trade_alert(
                                    action=exit_side,
                                    symbol=SYMBOL,
                                    price=order.get('price', latest_candle['close']),
                                    quantity=exit_size
                                )
                                
                                if action == 'exit_full':
                                    position_manager.in_position = False
                                    position_manager.position_details = {}
                                else: # partial exit
                                    pnl, remaining_size = position_manager.execute_partial_take_profit(
                                        exit_price=order.get('price', latest_candle['close']),
                                        timestamp=latest_candle.name
                                    )
                                    log_message(f"Partial exit complete. PnL: {pnl}, Remaining size: {remaining_size}")

                            except Exception as e:
                                log_message(f"ERROR: Failed to place exit order: {e}")
                
                log_message("Checking for entry...")
                # Check for entry
                if not position_manager.in_position:
                    trade_type, confidence = position_manager.check_for_entry(latest_candle, volume_metrics=latest_candle.get('volume_metrics', {}))
                    if trade_type:
                        log_message(f"Entry signal received: {trade_type} with confidence {confidence:.2f}")
                        
                        try:
                            balance = await exchange.fetch_balance()
                            quote_currency = SYMBOL.split('/')[1]
                            available_balance = balance['free'][quote_currency]
                            
                            entered = position_manager.enter_position(trade_type, latest_candle, available_balance)
                            
                            if entered:
                                position_size = position_manager.position_details.get('size')
                                if position_size and position_size > 0:
                                    side = 'buy' if trade_type == 'long' else 'sell'
                                    log_message(f"Attempting to place {side} ({trade_type}) order for {position_size} {SYMBOL.split('/')[0]}")
                                    order = await exchange.create_market_order(SYMBOL, side, position_size)
                                    log_message(f"Order placed successfully: {order['id']}")
                                    
                                    position_manager.position_details['exchange_order_id'] = order['id']
                                    position_manager.position_details['entry_price'] = order.get('price', latest_candle['close'])
                                    
                                    send_trade_alert(
                                        action=trade_type,
                                        symbol=SYMBOL,
                                        price=position_manager.position_details['entry_price'],
                                        quantity=position_size
                                    )
                                else:
                                    log_message("Position size is zero or invalid. No order placed.")
                                    position_manager.in_position = False
                                    position_manager.position_details = {}
                            else:
                                log_message("Failed to enter position in position manager.")
                        except Exception as e:
                            log_message(f"ERROR during entry logic: {e}")
                            log_message(traceback.format_exc())

                log_message("Saving state...")
                # Save state after every loop
                save_state(position_manager.get_state())
                log_message("State saved.")
                
                log_message("--- Main loop iteration finished, sleeping... ---")
                await asyncio.sleep(60) # Wait for 1 minute
                
            except Exception as e:
                log_message(f"An error occurred in the main loop: {e}")
                log_message(traceback.format_exc())
                await asyncio.sleep(60) # Wait before retrying
                
    except asyncio.CancelledError:
        log_message("Main run task was cancelled during shutdown.")
    except Exception as e:
        log_message(f"A critical error occurred in run(): {e}")
        log_message(traceback.format_exc())
    finally:
        log_message("Closing exchange connection...")
        if exchange and hasattr(exchange, 'close'):
            await exchange.close()
        log_message("Exchange connection closed.")


async def check_for_parameter_updates(strategy, position_manager, last_known_update_time):
    """
    Periodically checks GCS for new parameters and reloads them if found.
    """
    if not GCP_AVAILABLE:
        log_message("GCP not available. Parameter updates disabled.")
        return
        
    while True:
        await asyncio.sleep(300) # Check every 5 minutes
        try:
            log_message("Checking for parameter updates in GCS...")
            blob = get_gcs_blob_metadata("latest_live_parameters.json")
            if blob and (last_known_update_time is None or blob.updated > last_known_update_time):
                log_message(f"New parameters found in GCS (Updated: {blob.updated}). Reloading...")
                send_notification("Live Bot: New parameters detected, attempting to reload.")
                
                new_params, new_update_time = load_latest_parameters_from_gcs()
                
                if new_params:
                    strategy.params = new_params
                    position_manager.params = new_params
                    last_known_update_time = new_update_time
                    log_message("Successfully reloaded new parameters into strategy and position manager.")
                    send_notification("Live Bot: Parameters successfully reloaded.")
                else:
                    log_message("Failed to reload new parameters. Continuing with old parameters.")
            else:
                log_message("No new parameters found.")
        except Exception as e:
            log_message(f"Error during parameter update check: {e}")
            send_error_alert(f"Live Bot: Failed to check for parameter updates. Error: {e}")


if __name__ == '__main__':
    try:
        asyncio.run(run())
    except KeyboardInterrupt:
        log_message("Bot manually stopped by user (Ctrl+C).")
    except Exception as e:
        log_message(f"Unhandled exception in main: {e}")
        log_message(traceback.format_exc())
    finally:
        log_message("Shutdown complete.")
