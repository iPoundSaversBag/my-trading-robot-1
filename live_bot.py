# ==============================================================================
#
#                               LIVE TRADING BOT
#
# ==============================================================================
#
# FILE: live_bot.py
#
# PURPOSE:
#   This script is the execution engine for the live trading strategy. It is
#   designed to connect to the Binance exchange, monitor market data in real-time,
#   and execute trades based on the signals generated by the strategy that was
#   optimized by the backtesting framework.
#
# METHODOLOGY:
#   The bot operates in a continuous loop, fetching the latest market data at
#   regular intervals. In each iteration, it:
#   1.  Loads the most recently optimized parameters from `final_optimized_params.json`.
#   2.  Calculates all necessary technical indicators (Ichimoku, RSI, ADX, etc.)
#       based on the latest data and the loaded parameters.
#   3.  Generates entry and exit signals according to the same logic used in the
#       backtester.
#   4.  Connects to the Binance API to manage the account, check for open
#       positions, and execute new trades (buy/sell orders).
#   5.  Implements risk management rules, such as setting stop-loss and take-profit
#       levels for all trades.
#
# KEY FEATURES:
#   - Real-Time Operation: Designed to run continuously, making trading
#     decisions based on live market data.
#   - Exchange Integration: Uses the `binance.client` library to interact
#     directly with the Binance exchange for order execution and account management.
#   - Dynamic Parameter Loading: Automatically uses the latest and best parameters
#     found by the `watcher.py` optimization pipeline.
#   - Consistent Logic: Employs the exact same signal generation and trade
#     management logic as the backtester to ensure that live performance is
#     as close as possible to the simulated results.
#
# ==============================================================================

# live_bot.py - A framework for live trading that mirrors the backtester's logic.
# WARNING: FOR EDUCATIONAL AND PAPER-TRADING PURPOSES ONLY.
# DO NOT USE WITH A REAL MONEY ACCOUNT WITHOUT SIGNIFICANT TESTING AND ADDING MORE ROBUSTNESS.

import asyncio
import json
import os
import glob
import pandas as pd
import ta
import datetime
import sys
import ccxt.pro as ccxt
import warnings
import numpy as np
import traceback
import json5
import time
from google.api_core import exceptions
from ta.momentum import rsi
from ta.trend import adx, macd_diff
from dotenv import load_dotenv
from notifications import send_trade_alert, send_error_alert, send_notification
from strategy import Strategy
from portfolio import Portfolio
from position_manager import PositionManager
from gcp_utils import download_from_gcs, get_gcs_blob_metadata

load_dotenv()

# Suppress known, non-critical RuntimeWarning from numpy/pandas
warnings.filterwarnings("ignore", category=RuntimeWarning)

# ==============================================================================
# SECTION 1: API KEY CONFIGURATION
# ==============================================================================
# --- PASTE YOUR BINANCE API KEYS HERE ---
# For initial testing, use the keys from the Binance Spot TESTNET.
# https://testnet.binance.vision/
#
# CRITICAL: NEVER SHARE THIS FILE OR COMMIT IT TO A PUBLIC REPOSITORY.

API_KEY = os.getenv("API_KEY")
SECRET_KEY = os.getenv("SECRET_KEY")

# -------------------------------------------


# ==============================================================================
# SECTION 2: CORE BOT SETTINGS
# ==============================================================================
# -- Exchange and Symbol --

# -- File Paths --
PARAMS_BASE_DIR = "plots_output"
STATE_FILE = "live_bot_state.json"
LOG_FILE = "live_bot_log.txt"

# --- Set to False when you are ready to trade with real money ---


# ==============================================================================
# SECTION 3: HELPER FUNCTIONS & CLASSES (DO NOT MODIFY)
# ==============================================================================

def log_message(message):
    """Logs a message to both the console and a file."""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"[{timestamp}] {message}"
    print(log_line)
    with open(LOG_FILE, 'a') as f:
        f.write(log_line + '\n')

def load_state():
    """Loads the bot's current state (e.g., if it's in a position)."""
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, 'r') as f:
            log_message("State file found. Loading previous state.")
            return json.load(f)
    log_message("No state file found. Starting fresh.")
    return {"in_position": False, "position_details": {}}

def save_state(state):
    """Saves the bot's current state to a file after every action."""
    with open(STATE_FILE, 'w') as f:
        json.dump(state, f, indent=4)

def load_latest_parameters_from_gcs(retries=5, delay=2):
    """
    Downloads and loads the latest parameters from Google Cloud Storage, with retries.
    """
    local_params_file = "latest_live_parameters.json"
    for attempt in range(retries):
        try:
            log_message("Attempting to download latest parameters from GCS...")
            download_success = download_from_gcs(
                source_blob_name="latest_live_parameters.json",
                destination_file_path=local_params_file
            )

            if not download_success:
                raise FileNotFoundError("Failed to download parameters from GCS.")

            log_message(f"Successfully downloaded parameters. Loading from '{local_params_file}'")
            with open(local_params_file, 'r') as f:
                all_params = json.load(f)

            last_window_key = sorted(all_params.keys(), key=lambda w: int(w.split('_')[1]))[-1]
            log_message(f"Using parameters from '{last_window_key}'.")

            with open("optimization_config.json", 'r') as cfg_f:
                main_config = json5.load(cfg_f)
                fixed_params = main_config.get('fixed_parameters', {})
                optimization_settings = main_config.get('optimization_settings', {})

            final_params = {**all_params[last_window_key], **fixed_params, **optimization_settings}
            
            # Get metadata for the update check loop
            blob = get_gcs_blob_metadata("latest_live_parameters.json")
            last_updated = blob.updated if blob else None

            return final_params, last_updated

        except (FileNotFoundError, json.JSONDecodeError, exceptions.GoogleAPICallError) as e:
            if attempt < retries - 1:
                log_message(f"Attempt {attempt + 1}/{retries} failed to load GCS parameters: {e}. Retrying in {delay}s...")
                time.sleep(delay)
            else:
                log_message(f"CRITICAL: Could not load parameters from GCS after {retries} attempts. Last error: {e}")
                raise
    return None, None



async def check_for_parameter_updates(strategy, position_manager, last_known_update_time):
    """
    Periodically checks GCS for new parameters and reloads them if found.
    """
    while True:
        await asyncio.sleep(300) # Check every 5 minutes
        try:
            log_message("Checking for parameter updates in GCS...")
            blob = get_gcs_blob_metadata("latest_live_parameters.json")
            if blob and (last_known_update_time is None or blob.updated > last_known_update_time):
                log_message(f"New parameters found in GCS (Updated: {blob.updated}). Reloading...")
                send_notification("Live Bot: New parameters detected, attempting to reload.")
                
                new_params, new_update_time = load_latest_parameters_from_gcs()
                
                if new_params:
                    strategy.params = new_params
                    position_manager.params = new_params
                    last_known_update_time = new_update_time
                    log_message("Successfully reloaded new parameters into strategy and position manager.")
                    send_notification("Live Bot: Parameters successfully reloaded.")
                else:
                    log_message("Failed to reload new parameters. Continuing with old parameters.")
            else:
                log_message("No new parameters found.")
        except Exception as e:
            log_message(f"Error during parameter update check: {e}")
            send_error_alert(f"Live Bot: Failed to check for parameter updates. Error: {e}")

async def check_for_parameter_updates(strategy, position_manager, last_known_update_time):
    """
    Periodically checks GCS for new parameters and reloads them if found.
    """
    while True:
        await asyncio.sleep(300) # Check every 5 minutes
        try:
            log_message("Checking for parameter updates in GCS...")
            blob = get_gcs_blob_metadata("latest_live_parameters.json")
            if blob and (last_known_update_time is None or blob.updated > last_known_update_time):
                log_message(f"New parameters found in GCS (Updated: {blob.updated}). Reloading...")
                send_notification("Live Bot: New parameters detected, attempting to reload.")
                
                new_params, new_update_time = load_latest_parameters_from_gcs()
                
                if new_params:
                    strategy.params = new_params
                    position_manager.params = new_params
                    last_known_update_time = new_update_time
                    log_message("Successfully reloaded new parameters into strategy and position manager.")
                    send_notification("Live Bot: Parameters successfully reloaded.")
                else:
                    log_message("Failed to reload new parameters. Continuing with old parameters.")
            else:
                log_message("No new parameters found.")
        except Exception as e:
            log_message(f"Error during parameter update check: {e}")
            send_error_alert(f"Live Bot: Failed to check for parameter updates. Error: {e}")

# ==============================================================================
# SECTION 4: MAIN BOT LOGIC
# ==============================================================================
async def run():
    """The main entry point and loop for the bot."""
    exchange = None
    try:
        # FIX: Clear the log file at the start of each new run
        if os.path.exists(LOG_FILE):
            os.remove(LOG_FILE)
            
        # Load the main configuration
        with open("optimization_config.json", 'r') as f:
            config = json5.load(f)
        bot_settings = config.get('bot_settings', {})

        EXCHANGE_NAME = bot_settings.get('exchange_name', 'binance')
        SYMBOL = bot_settings.get('symbol', 'BTC/USDT')
        TIMEFRAME = bot_settings.get('timeframe', '5m')
        USE_TESTNET = bot_settings.get('use_testnet', True)

        log_message(f"Initializing Live Trading Bot for {SYMBOL} on {EXCHANGE_NAME} ({TIMEFRAME})...")
        
        state = load_state()
        params, last_gcs_update_time = load_latest_parameters_from_gcs()
        if params is None:
            log_message("CRITICAL: Bot cannot start without initial parameters. Exiting.")
            return
        strategy = Strategy(params)
        # We will get the proper initial capital after connecting to the exchange
        portfolio = Portfolio(initial_capital=10000)
        position_manager = PositionManager(params)
        position_manager.load_state(state)

        exchange_class = getattr(ccxt, EXCHANGE_NAME)
        exchange = exchange_class({'apiKey': API_KEY, 'secret': SECRET_KEY, 'enableRateLimit': True})
        
        if USE_TESTNET:
            log_message("--- CONNECTING TO BINANCE TESTNET (PAPER TRADING) ---")
            exchange.set_sandbox_mode(True)
        else:
            log_message("--- CONNECTING TO LIVE BINANCE (REAL MONEY) ---")

        try:
            balance = await exchange.fetch_balance()
            usdt_balance = balance['total'].get('USDT', 0)
            log_message(f"Connected to exchange. Current USDT balance: {usdt_balance:.2f}")
        except Exception as e:
            log_message(f"Could not fetch balance: {e}")

        log_message("Fetching initial historical data to warm up indicators...")
        # FIX: Dynamically and accurately determine the required data length based on the needs
        # of all indicators, especially ADX and Ichimoku which have longer requirements.
        adx_len = (params.get('ADX_PERIOD', 20) * 2) + 50 # ADX needs ~2x period
        ichimoku_len = params.get('SENKOU_SPAN_B_PERIOD', 52) + params.get('KIJUN_SEN_PERIOD', 26)

        required_periods = [
            params.get(p, 20) for p in [
                'TENKAN_SEN_PERIOD', 'KIJUN_SEN_PERIOD', 'SENKOU_SPAN_B_PERIOD', 
                'RSI_PERIOD', 'ADX_PERIOD', 'ATR_PERIOD', 'BBANDS_PERIOD', 'RSI_LOOKBACK'
            ]
        ]
        required_periods.extend([adx_len, ichimoku_len])
        limit = max(required_periods) + 50 # Add a buffer for safety
        
        log_message(f"Required data points based on parameters: {limit}")
        ohlcv = await exchange.fetch_ohlcv(SYMBOL, TIMEFRAME, limit=limit)
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        log_message("Initial data loaded. Bot is starting and waiting for new candles...")

        # --- DYNAMIC RELOADING: Start the background task to check for updates ---
        update_task = asyncio.create_task(
            check_for_parameter_updates(strategy, position_manager, last_gcs_update_time)
        )

        while True:
            try:
                new_candle_data = await exchange.watch_ohlcv(SYMBOL, TIMEFRAME)
                
                new_row = pd.DataFrame(new_candle_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                new_row['timestamp'] = pd.to_datetime(new_row['timestamp'], unit='ms')
                new_row.set_index('timestamp', inplace=True)
                df = pd.concat([df, new_row])
                df = df[~df.index.duplicated(keep='last')]
                df = df.iloc[-limit:]
                
                processed_df = strategy.generate_signals(df)
                if processed_df.empty:
                    log_message("Data preparation failed, skipping cycle.")
                    await asyncio.sleep(10)
                    continue

                latest_candle = processed_df.iloc[-1]
                
                # --- Core Logic ---
                current_balance = usdt_balance # Fallback to initial balance
                try:
                    balance = await exchange.fetch_balance()
                    current_balance = balance['total'].get('USDT', usdt_balance)
                except Exception as e:
                    log_message(f"Could not fetch updated balance, using last known value. Error: {e}")


                if position_manager.in_position:
                    # 1. Update trailing stop loss first
                    position_manager.update_trailing_stop(latest_candle)
                    
                    # 2. Check for an exit signal
                    exit_reason = position_manager.check_for_exit(latest_candle)
                    if exit_reason:
                        log_message(f"EXIT SIGNAL: Reason: {exit_reason}")
                        exit_price = latest_candle['close']
                        
                        # Use the unified position manager to calculate P&L and get exit size
                        pnl, size_to_exit = position_manager.exit_position(exit_reason, exit_price)
                        
                        # Create the market order
                        order_side = 'sell' if position_manager.position_details.get('type') == 'long' else 'buy'
                        order = await exchange.create_market_order(SYMBOL, order_side, size_to_exit)
                        log_message(f"Submitted exit order: {order['id']}")
                        
                        # --- REAL-WORLD HARDENING: Verify order fill ---
                        try:
                            # Wait for the order to be filled
                            await asyncio.sleep(5) # Wait 5 seconds for propagation
                            filled_order = await exchange.fetch_order(order['id'], SYMBOL)
                            
                            if filled_order['status'] == 'closed':
                                log_message(f"Order {order['id']} confirmed filled.")
                                usdt_balance += pnl # Update balance with PnL
                                log_message(f"  - P/L for this exit: {pnl:+.2f} USDT")
                            else:
                                log_message(f"WARNING: Exit order {order['id']} not confirmed filled. Status: {filled_order['status']}. Manual check required.")
                                send_error_alert(f"Exit order {order['id']} for {SYMBOL} not confirmed filled.")
                        except Exception as e:
                            log_message(f"ERROR: Could not verify exit order fill: {e}")
                            send_error_alert(f"Could not verify exit order fill for {SYMBOL}: {e}")
                else:
                    # Check for an entry signal
                    trade_type, _ = position_manager.check_for_entry(latest_candle)
                    if trade_type:
                        log_message(f"!!! TRADE SIGNAL: ATTEMPTING TO GO {trade_type.upper()} !!!")
                        # Calculate size and attempt to enter
                        if position_manager.enter_position(trade_type, latest_candle, current_balance):
                            pos_details = position_manager.position_details
                            log_message(f"NEW POSITION: {pos_details}")
                            
                            # Create the market order
                            order = await exchange.create_market_order(
                                SYMBOL,
                                'buy' if pos_details['type'] == 'long' else 'sell',
                                pos_details['size']
                            )
                            log_message(f"Submitted entry order: {order['id']}")

                            # --- REAL-WORLD HARDENING: Verify order fill ---
                            try:
                                await asyncio.sleep(5) # Wait 5 seconds
                                filled_order = await exchange.fetch_order(order['id'], SYMBOL)
                                if filled_order['status'] != 'closed':
                                     log_message(f"WARNING: Entry order {order['id']} not confirmed filled. Status: {filled_order['status']}. Manual check required.")
                                     send_error_alert(f"Entry order {order['id']} for {SYMBOL} not confirmed filled.")
                                     # If entry fails, reset position state
                                     position_manager.in_position = False
                                     position_manager.position_details = {}
                                else:
                                    log_message(f"Order {order['id']} confirmed filled.")
                            except Exception as e:
                                log_message(f"ERROR: Could not verify entry order fill: {e}")
                                send_error_alert(f"Could not verify entry order fill for {SYMBOL}: {e}")
                                # If verification fails, assume the worst and reset state
                                position_manager.in_position = False
                                position_manager.position_details = {}
                        else:
                            log_message("Entry condition met, but trade execution failed.")

                # Save state after every cycle
                save_state(position_manager.get_state())

            except ccxt.NetworkError as e:
                log_message(f"NETWORK ERROR: {e}. Retrying in 30 seconds...")
                await asyncio.sleep(30)
            except ccxt.ExchangeError as e:
                log_message(f"EXCHANGE ERROR: {e}. Retrying in 60 seconds...")
                await asyncio.sleep(60)
            except Exception as e:
                log_message(f"An unexpected error occurred in the main loop: {e}")
                log_message(traceback.format_exc())
                log_message("Bot will sleep for 1 minute before retrying.")
                await asyncio.sleep(60)

    except asyncio.CancelledError:
        log_message("Bot run was cancelled.")
    except Exception as e:
        log_message(f"CRITICAL ERROR: The bot has crashed. Error: {e}")
        log_message(traceback.format_exc())
    finally:
        if 'update_task' in locals() and not update_task.done():
            update_task.cancel()
        if exchange:
            log_message("Closing exchange connection...")
            await exchange.close()


if __name__ == "__main__":
    # Use asyncio.run() which is the modern way to run async functions
    try:
        asyncio.run(run())
    except KeyboardInterrupt:
        log_message("Bot stopped manually by user.")
